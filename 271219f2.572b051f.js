(window.webpackJsonp=window.webpackJsonp||[]).push([[6],{60:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return i})),n.d(t,"rightToc",(function(){return c})),n.d(t,"default",(function(){return d}));var a=n(2),o=n(6),r=(n(0),n(72)),s={title:"Organising code",sidebar_label:"Organising code"},i={unversionedId:"organisation",id:"organisation",isDocsHomePage:!1,title:"Organising code",description:"Visly State doesn't care how you organize your state, selectors, and mutations. However we have discovered some patterns while building Visly which may be helpful to you as you adopt Visly State in your own applications.",source:"@site/docs/organisation.md",slug:"/organisation",permalink:"/docs/organisation",editUrl:"https://github.com/vislyhq/visly-state/edit/master/website/docs/organisation.md",version:"current",sidebar_label:"Organising code",sidebar:"docs",previous:{title:"Syncing state",permalink:"/docs/syncing"}},c=[{value:"Combinding local and remote state",id:"combinding-local-and-remote-state",children:[]},{value:"Namespacing selectors and mutations",id:"namespacing-selectors-and-mutations",children:[]},{value:"Using smaller states for independant features",id:"using-smaller-states-for-independant-features",children:[]},{value:"Seperating shared code",id:"seperating-shared-code",children:[]}],l={rightToc:c};function d(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"Visly State doesn't care how you organize your state, selectors, and mutations. However we have discovered some patterns while building Visly which may be helpful to you as you adopt Visly State in your own applications."),Object(r.b)("h2",{id:"combinding-local-and-remote-state"},"Combinding local and remote state"),Object(r.b)("p",null,"Typically you want to have both local and remote state which depends on one another. For example your data models will be remote state synced to the server but you'll also have local state such as what item is currently selected by the use which you don't want to sync to the server but hich at the same time is dependant on what items exist in the data model. For this we rely on ",Object(r.b)("inlineCode",{parentName:"p"},"combinedState")," to combine the remote and local stores and write mutations and selectors which operate on this combined store."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"import { syncedState } from '@visly/state'\n\ninterface RemoteState {\n    items: Item[]\n}\n\ninterface LocalState {\n    selectedItemId: string | null\n}\n\ntype AppState = {\n    remote: RemoteState\n    local: LocalState\n}\n\nconst remoteState = syncedState<RemoteState>('remote', { items: [] })\nconst localState = state<LocalState>({ selectedItemId: null })\n\nexport const appState = combinedState<AppState>({\n    remote: remoteState,\n    local: localState,\n})\n\nexport const mutations = {\n    addItem: (state: AppState, item: Item) => {\n        state.remote.items.push(item)\n        state.local.selectedItemId = item.id\n    }\n}\n\nexport const selectors = {\n    selectedItem: (state: AppState) => {\n        return state.remote.items.find(item => {\n            return item.id === state.local.selectedItemId\n        })\n    }\n}\n")),Object(r.b)("h2",{id:"namespacing-selectors-and-mutations"},"Namespacing selectors and mutations"),Object(r.b)("p",null,"As you may have noticed throughout the examples we tend to place mutations and selectors within exported objects called ",Object(r.b)("inlineCode",{parentName:"p"},"mutations")," and ",Object(r.b)("inlineCode",{parentName:"p"},"selectors"),". We typically export these object from the module which defines the state. This makes it very obvious to the other developers which operations exist on the state."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-tsx"}),"import { state } from '@visly/state'\n\nexport const appState = state({ ... })\nexport const mutations = { ... }\nexport const selectors = { ... }\n")),Object(r.b)("h2",{id:"using-smaller-states-for-independant-features"},"Using smaller states for independant features"),Object(r.b)("p",null,"We typically have one large state which holds all the main data models for the application but then we also have many smaller stores for independant features. For example in Visly we have the ability to pan around and zoom in on the main editor canvas, we store this state in a ",Object(r.b)("inlineCode",{parentName:"p"},"zoomStore")," as it is independant from data in any other stores."),Object(r.b)("h2",{id:"seperating-shared-code"},"Seperating shared code"),Object(r.b)("p",null,"We recommend creating a module with no React / browser dependencies which holds the state, selectors, and mutations which operate on data which is shared between Both React and Node environments. This way code is easily shared between client and server. If we wish to add any React-specific functionaility such as custom hooks wrapping state operations we place these outside of the main shared module. This makes state easy to re-use and test. "))}d.isMDXComponent=!0},72:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return h}));var a=n(0),o=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=o.a.createContext({}),d=function(e){var t=o.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=d(e.components);return o.a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},u=o.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=d(n),u=a,h=p["".concat(s,".").concat(u)]||p[u]||m[u]||r;return n?o.a.createElement(h,i(i({ref:t},l),{},{components:n})):o.a.createElement(h,i({ref:t},l))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<r;l++)s[l]=n[l];return o.a.createElement.apply(null,s)}return o.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);